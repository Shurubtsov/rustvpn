# RustVPN — xray-core Configuration Reference

## What is REALITY?

REALITY is a TLS-based obfuscation protocol developed by the XTLS project. It is an extension of the VLESS proxy protocol that makes VPN traffic indistinguishable from legitimate TLS 1.3 traffic to a real website.

**How it works:**

1. The xray client performs a full TLS 1.3 handshake with a legitimate target domain (the SNI, e.g. `www.microsoft.com`). This traffic is real TLS, signed by the domain's real certificate.
2. Inside that TLS session, xray embeds a short authentication token that the REALITY server (on the VDS) recognizes.
3. From a DPI (Deep Packet Inspection) perspective, the traffic looks like a browser visiting `www.microsoft.com` with no observable difference from legitimate traffic — there is no custom certificate, no foreign SNI, and no detectable protocol header.

**Key parameters:**

| Parameter | Description |
|-----------|-------------|
| `public_key` | Server's X25519 public key. Used by the client to authenticate the server during the REALITY handshake. Generated on the server with `xray x25519`. |
| `short_id` | A short hex string (up to 16 hex chars) that identifies the client session. Must match one of the `shortIds` configured on the server. |
| `server_name` (SNI) | A real domain the server's IP can reach over TLS. The client uses this as the TLS SNI. The server proxies the handshake to this domain. |
| `fingerprint` | TLS client hello fingerprint to emulate (`chrome`, `firefox`, `safari`, `edge`, etc.). |

## Client Configuration

The client config is generated by `src-tauri/src/config.rs` (`generate_client_config()`) each time the user connects. It is written to `<app_data_dir>/xray_config.json` and passed to xray via `xray run -c <path>`.

### Full client config (example)

```json
{
  "log": {
    "loglevel": "warning"
  },
  "dns": {
    "servers": [
      "1.1.1.1",
      "8.8.8.8"
    ]
  },
  "inbounds": [
    {
      "tag": "socks-in",
      "port": 10808,
      "listen": "127.0.0.1",
      "protocol": "socks",
      "settings": {
        "udp": true
      },
      "sniffing": {
        "enabled": true,
        "destOverride": ["http", "tls"]
      }
    }
  ],
  "outbounds": [
    {
      "tag": "proxy",
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "45.151.233.107",
            "port": 443,
            "users": [
              {
                "id": "b472a988-1cd7-4221-b76f-9cea35f2df2f",
                "flow": "xtls-rprx-vision",
                "encryption": "none"
              }
            ]
          }
        ]
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "fingerprint": "chrome",
          "serverName": "www.microsoft.com",
          "publicKey": "kieJgZYLW9ZiKbGLpKnv4XyVo6_42inSONJrr-96tUU",
          "shortId": "d64736262cd50811"
        }
      }
    },
    {
      "tag": "direct",
      "protocol": "freedom"
    },
    {
      "tag": "block",
      "protocol": "blackhole"
    }
  ],
  "routing": {
    "domainStrategy": "IPIfNonMatch",
    "rules": [
      {
        "type": "field",
        "outboundTag": "direct",
        "domain": ["geosite:private"]
      },
      {
        "type": "field",
        "outboundTag": "direct",
        "ip": ["geoip:private"]
      }
    ]
  }
}
```

### Config sections explained

**`log`** — xray-core log verbosity. Set to `warning` to reduce noise.

**`dns`** — DNS resolvers used by xray for domain lookups. Cloudflare (1.1.1.1) and Google (8.8.8.8) are hardcoded.

**`inbounds`** — The local SOCKS5 proxy that applications use to route traffic through xray:
- Listens on `127.0.0.1:10808`
- Accepts SOCKS5 with UDP support
- Sniffing enabled for HTTP and TLS traffic (allows xray to route by domain even if only an IP was provided)

**`outbounds`** — Three outbounds are always generated:
- `proxy` — VLESS+REALITY outbound to the VDS server (default outbound)
- `direct` — `freedom` protocol, used for private/LAN traffic
- `block` — `blackhole` protocol, used to drop traffic (currently unused in routing rules but present for future use)

**`routing`** — Private IP ranges and private domains (`geosite:private`, `geoip:private`) bypass the VPN and go direct. All other traffic goes through the `proxy` outbound.

## Server Configuration (VDS)

The server-side xray configuration is managed outside the app (directly on the VDS). Below is a reference config for setting up a VLESS+REALITY server.

```json
{
  "log": {
    "loglevel": "warning"
  },
  "inbounds": [
    {
      "port": 443,
      "protocol": "vless",
      "settings": {
        "clients": [
          {
            "id": "b472a988-1cd7-4221-b76f-9cea35f2df2f",
            "flow": "xtls-rprx-vision"
          }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "www.microsoft.com:443",
          "serverNames": ["www.microsoft.com"],
          "privateKey": "<server-private-key>",
          "shortIds": ["d64736262cd50811"]
        }
      }
    }
  ],
  "outbounds": [
    {
      "protocol": "freedom",
      "tag": "direct"
    }
  ]
}
```

**Generate server keypair:**
```bash
xray x25519
# Private key: <keep secret on server>
# Public key:  <share with clients>
```

## SOCKS5 Proxy Port

xray always listens on `127.0.0.1:10808` (hardcoded as `DEFAULT_SOCKS_PORT` in `xray.rs`). Configure applications to use this SOCKS5 proxy, or set it system-wide.

## vless:// URI Format

The vless:// URI is a shareable string encoding all parameters needed to configure a server. RustVPN can import and export these URIs.

### Format specification

```
vless://UUID@ADDRESS:PORT?encryption=none&flow=FLOW&type=tcp&security=reality&sni=SNI&fp=FINGERPRINT&pbk=PUBLIC_KEY&sid=SHORT_ID#NAME
```

| Component | Description |
|-----------|-------------|
| `UUID` | User UUID (VLESS credential), format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx` |
| `ADDRESS` | Server IP address or hostname. IPv6 addresses are wrapped in brackets: `[::1]` |
| `PORT` | Server port (1–65535) |
| `encryption` | Always `none` for VLESS |
| `flow` | XTLS flow control, typically `xtls-rprx-vision` |
| `type` | Transport type, always `tcp` |
| `security` | Always `reality` |
| `sni` | TLS SNI (the legitimate domain to impersonate) |
| `fp` | TLS fingerprint (`chrome`, `firefox`, `safari`, `edge`, etc.) |
| `pbk` | Server's X25519 public key (Base64url) |
| `sid` | Short ID (hex string, max 16 chars) |
| `#NAME` | Human-readable server name (URL-encoded) |

### Example URI

```
vless://b472a988-1cd7-4221-b76f-9cea35f2df2f@45.151.233.107:443?encryption=none&flow=xtls-rprx-vision&type=tcp&security=reality&sni=www.microsoft.com&fp=chrome&pbk=kieJgZYLW9ZiKbGLpKnv4XyVo6_42inSONJrr-96tUU&sid=d64736262cd50811#Finland%20VDS
```

### URI parsing behavior (`uri.rs`)

- Unknown query parameters are silently ignored (e.g. `encryption`, `type`).
- Fragment (`#NAME`) is URL-decoded to produce the server's display name.
- If no fragment is present, `name` is set to an empty string.
- IPv6 addresses are supported in bracket notation: `[2001:db8::1]`.
- A fresh UUID v4 is always assigned as the internal server `id` when parsing; the UUID in the URI is the VLESS user credential, stored in the `uuid` field.
- Port values outside the valid u16 range (0–65535) produce a parse error.

### Roundtrip guarantee

`to_vless_uri(server)` followed by `parse_vless_uri(uri)` produces a `ServerConfig` with identical field values (all except `id`, which gets a new UUID v4 on parse).

## Adding a New Server

### Method 1: Manual entry (via UI form)

1. Click **+ Add** in the server list.
2. Fill in the required fields:
   - Address, Port, UUID
   - REALITY: Public Key, Short ID, SNI, Fingerprint
3. Click **Add Server**.

Required fields: `address`, `port` (1–65535), `uuid` (valid UUID format), `public_key`, `short_id`, `server_name`, `fingerprint`.

The `flow` field defaults to `xtls-rprx-vision`. The `name` field defaults to the address if left blank.

### Method 2: Import from vless:// URI

1. Click **Import** → **From vless:// URI**.
2. Paste the full `vless://...` URI.
3. Click **Import**.

The URI is parsed on the Rust side (`parse_vless_uri_cmd`), validated, and stored.

### Method 3: Import from JSON file

1. Click **Import** → **From File**.
2. Select a `.json` file containing a JSON array of `ServerConfig` objects.
3. All servers are added with fresh IDs (no collision with existing entries).

JSON format:
```json
[
  {
    "name": "Finland VDS",
    "address": "45.151.233.107",
    "port": 443,
    "uuid": "b472a988-1cd7-4221-b76f-9cea35f2df2f",
    "flow": "xtls-rprx-vision",
    "reality": {
      "public_key": "kieJgZYLW9ZiKbGLpKnv4XyVo6_42inSONJrr-96tUU",
      "short_id": "d64736262cd50811",
      "server_name": "www.microsoft.com",
      "fingerprint": "chrome"
    }
  }
]
```

Note: `id` is optional in the import JSON — it is always replaced with a fresh UUID v4 to prevent collisions.
